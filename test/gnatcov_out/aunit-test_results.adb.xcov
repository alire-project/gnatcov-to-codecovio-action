/home/chouteau/src/github/alire/ada_spark_workflow/tests/alire/cache/dependencies/aunit_22.0.0_cbd7a80a/include/aunit/framework/aunit-test_results.adb:
0% of 61 lines covered
0% statement coverage (0 out of 61)

Coverage level: stmt
   1 .: ------------------------------------------------------------------------------
   2 .: --                                                                          --
   3 .: --                         GNAT COMPILER COMPONENTS                         --
   4 .: --                                                                          --
   5 .: --                    A U N I T . T E S T _ R E S U L T S                   --
   6 .: --                                                                          --
   7 .: --                                 B o d y                                  --
   8 .: --                                                                          --
   9 .: --                                                                          --
  10 .: --                       Copyright (C) 2000-2011, AdaCore                   --
  11 .: --                                                                          --
  12 .: -- GNAT is free software;  you can  redistribute it  and/or modify it under --
  13 .: -- terms of the  GNU General Public License as published  by the Free Soft- --
  14 .: -- ware  Foundation;  either version 3,  or (at your option) any later ver- --
  15 .: -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
  16 .: -- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
  17 .: -- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
  18 .: --                                                                          --
  19 .: -- As a special exception under Section 7 of GPL version 3, you are granted --
  20 .: -- additional permissions described in the GCC Runtime Library Exception,   --
  21 .: -- version 3.1, as published by the Free Software Foundation.               --
  22 .: --                                                                          --
  23 .: -- You should have received a copy of the GNU General Public License and    --
  24 .: -- a copy of the GCC Runtime Library Exception along with this program;     --
  25 .: -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
  26 .: -- <http://www.gnu.org/licenses/>.                                          --
  27 .: --                                                                          --
  28 .: -- GNAT is maintained by AdaCore (http://www.adacore.com)                   --
  29 .: --                                                                          --
  30 .: ------------------------------------------------------------------------------
  31 .: 
  32 .: with AUnit.Memory.Utils;
  33 .: 
  34 .: --  Record test results.
  35 .: 
  36 .: package body AUnit.Test_Results is
  37 .: 
  38 .:    -----------------------
  39 .:    -- Local Subprograms --
  40 .:    -----------------------
  41 .: 
  42 -:    function Alloc_Failure is new AUnit.Memory.Utils.Gen_Alloc
  43 -:      (Test_Failure, Test_Failure_Access);
  44 .: 
  45 -:    function Alloc_Error is new AUnit.Memory.Utils.Gen_Alloc
  46 -:      (Test_Error, Test_Error_Access);
  47 .: 
  48 -:    E_Count : Count_Type;
  49 -:    F_Count : Count_Type;
  50 -:    S_Count : Count_Type;
  51 .: 
  52 .:    procedure Iterate_Error (Position : Result_Lists.Cursor);
  53 .:    procedure Iterate_Failure (Position : Result_Lists.Cursor);
  54 .:    procedure Iterate_Success (Position : Result_Lists.Cursor);
  55 .: 
  56 .:    function Is_Error (Position : Result_Lists.Cursor) return Boolean;
  57 .:    function Is_Failure (Position : Result_Lists.Cursor) return Boolean;
  58 .:    function Is_Success (Position : Result_Lists.Cursor) return Boolean;
  59 .: 
  60 .:    generic
  61 .:       with function Test (Position : Result_Lists.Cursor) return Boolean;
  62 .:    procedure Gen_Extract (R : Result;
  63 .:                           E : in out Result_Lists.List);
  64 .: 
  65 .:    -------------------
  66 .:    -- Iterate_Error --
  67 .:    -------------------
  68 .: 
  69 .:    procedure Iterate_Error (Position : Result_Lists.Cursor) is
  70 .:    begin
  71 -:       if Result_Lists.Element (Position).Error /= null then
  72 -:          E_Count := E_Count + 1;
  73 .:       end if;
  74 .:    end Iterate_Error;
  75 .: 
  76 .:    ---------------------
  77 .:    -- Iterate_Failure --
  78 .:    ---------------------
  79 .: 
  80 .:    procedure Iterate_Failure (Position : Result_Lists.Cursor) is
  81 .:    begin
  82 -:       if Result_Lists.Element (Position).Failure /= null then
  83 -:          F_Count := F_Count + 1;
  84 .:       end if;
  85 .:    end Iterate_Failure;
  86 .: 
  87 .:    ---------------------
  88 .:    -- Iterate_Success --
  89 .:    ---------------------
  90 .: 
  91 .:    procedure Iterate_Success (Position : Result_Lists.Cursor) is
  92 .:    begin
  93 -:       if Result_Lists.Element (Position).Error = null
  94 -:         and then Result_Lists.Element (Position).Failure = null
  95 .:       then
  96 -:          S_Count := S_Count + 1;
  97 .:       end if;
  98 .:    end Iterate_Success;
  99 .: 
 100 .:    -----------------
 101 .:    -- Gen_Extract --
 102 .:    -----------------
 103 .: 
 104 .:    procedure Gen_Extract
 105 .:      (R : Result;
 106 .:       E : in out Result_Lists.List)
 107 .:    is
 108 -:       C : Result_Lists.Cursor;
 109 .:       use Result_Lists;
 110 .:    begin
 111 -:       C := First (R.Result_List);
 112 .: 
 113 -:       while Has_Element (C) loop
 114 -:          if Test (C) then
 115 -:             E.Append (Element (C));
 116 .:          end if;
 117 -:          Next (C);
 118 .:       end loop;
 119 .:    end Gen_Extract;
 120 .: 
 121 .:    --------------
 122 .:    -- Is_Error --
 123 .:    --------------
 124 .: 
 125 .:    function Is_Error (Position : Result_Lists.Cursor) return Boolean is
 126 .:    begin
 127 -:       return Result_Lists.Element (Position).Error /= null;
 128 .:    end Is_Error;
 129 .: 
 130 .:    ----------------
 131 .:    -- Is_Failure --
 132 .:    ----------------
 133 .: 
 134 .:    function Is_Failure (Position : Result_Lists.Cursor) return Boolean is
 135 .:    begin
 136 -:       return Result_Lists.Element (Position).Failure /= null;
 137 .:    end Is_Failure;
 138 .: 
 139 .:    ----------------
 140 .:    -- Is_Success --
 141 .:    ----------------
 142 .: 
 143 .:    function Is_Success (Position : Result_Lists.Cursor) return Boolean is
 144 .:    begin
 145 -:       return not Is_Error (Position) and then not Is_Failure (Position);
 146 .:    end Is_Success;
 147 .: 
 148 .:    ---------------
 149 .:    -- Add_Error --
 150 .:    ---------------
 151 .: 
 152 .:    procedure Add_Error
 153 .:      (R            : in out Result;
 154 .:       Test_Name    : Message_String;
 155 .:       Routine_Name : Message_String;
 156 .:       Error        : Test_Error;
 157 .:       Elapsed      : Time)
 158 .:    is
 159 -:       Val : constant Test_Result := (Test_Name, Routine_Name,
 160 -:                                      Failure => null,
 161 -:                                      Error   => Alloc_Error,
 162 -:                                      Elapsed => Elapsed);
 163 .:       use Result_Lists;
 164 .:    begin
 165 .: 
 166 -:       Val.Error.all := Error;
 167 -:       Append (R.Result_List, Val);
 168 .:    end Add_Error;
 169 .: 
 170 .:    -----------------
 171 .:    -- Add_Failure --
 172 .:    -----------------
 173 .: 
 174 .:    procedure Add_Failure
 175 .:      (R            : in out Result;
 176 .:       Test_Name    : Message_String;
 177 .:       Routine_Name : Message_String;
 178 .:       Failure      : Test_Failure;
 179 .:       Elapsed      : Time) is
 180 .: 
 181 -:       Val : constant Test_Result := (Test_Name, Routine_Name,
 182 -:                                      Failure => Alloc_Failure,
 183 -:                                      Error   => null,
 184 -:                                      Elapsed => Elapsed);
 185 .:       use Result_Lists;
 186 .:    begin
 187 .: 
 188 -:       Val.Failure.all := Failure;
 189 -:       Append (R.Result_List, Val);
 190 .:    end Add_Failure;
 191 .: 
 192 .:    -----------------
 193 .:    -- Add_Success --
 194 .:    -----------------
 195 .: 
 196 .:    procedure Add_Success
 197 .:      (R                       : in out Result;
 198 .:       Test_Name               : Message_String;
 199 .:       Routine_Name            : Message_String;
 200 .:       Elapsed                 : Time) is
 201 .: 
 202 -:       Val : constant Test_Result :=
 203 -:               (Test_Name, Routine_Name, null, null, Elapsed);
 204 .:       use Result_Lists;
 205 .: 
 206 .:    begin
 207 -:       Append (R.Result_List, Val);
 208 .:    end Add_Success;
 209 .: 
 210 .:    -----------------
 211 .:    -- Set_Elapsed --
 212 .:    -----------------
 213 .: 
 214 .:    procedure Set_Elapsed (R : in out Result;
 215 .:                           T : Time_Measure.Time) is
 216 .:    begin
 217 -:       R.Elapsed_Time := T;
 218 .:    end Set_Elapsed;
 219 .: 
 220 .:    -----------------
 221 .:    -- Error_Count --
 222 .:    -----------------
 223 .: 
 224 .:    function Error_Count (R : Result) return Count_Type is
 225 .:       use Result_Lists;
 226 .:    begin
 227 -:       E_Count := 0;
 228 -:       Iterate (R.Result_List, Iterate_Error'Access);
 229 -:       return E_Count;
 230 .:    end Error_Count;
 231 .: 
 232 .:    ------------
 233 .:    -- Errors --
 234 .:    ------------
 235 .: 
 236 .:    procedure Errors (R : Result;
 237 .:                      E : in out Result_Lists.List) is
 238 -:       procedure Extract is new Gen_Extract (Is_Error);
 239 .:    begin
 240 -:       Extract (R, E);
 241 .:    end Errors;
 242 .: 
 243 .:    -------------------
 244 .:    -- Failure_Count --
 245 .:    -------------------
 246 .: 
 247 .:    function Failure_Count (R : Result) return Count_Type is
 248 .:       use Result_Lists;
 249 .:    begin
 250 -:       F_Count := 0;
 251 -:       Iterate (R.Result_List, Iterate_Failure'Access);
 252 -:       return F_Count;
 253 .:    end Failure_Count;
 254 .: 
 255 .:    --------------
 256 .:    -- Failures --
 257 .:    --------------
 258 .: 
 259 .:    procedure Failures (R : Result;
 260 .:                        F : in out Result_Lists.List) is
 261 -:       procedure Extract is new Gen_Extract (Is_Failure);
 262 .:    begin
 263 -:       Extract (R, F);
 264 .:    end Failures;
 265 .: 
 266 .:    -------------
 267 .:    -- Elapsed --
 268 .:    -------------
 269 .: 
 270 .:    function Elapsed (R : Result) return Time_Measure.Time is
 271 .:    begin
 272 -:       return R.Elapsed_Time;
 273 .:    end Elapsed;
 274 .: 
 275 .:    ----------------
 276 .:    -- Start_Test --
 277 .:    ----------------
 278 .: 
 279 .:    procedure Start_Test (R : in out Result; Subtest_Count : Count_Type) is
 280 .:    begin
 281 -:       R.Tests_Run := R.Tests_Run + Subtest_Count;
 282 .:    end Start_Test;
 283 .: 
 284 .:    -------------------
 285 .:    -- Success_Count --
 286 .:    -------------------
 287 .: 
 288 .:    function Success_Count (R : Result)  return Count_Type is
 289 .:    begin
 290 -:       S_Count := 0;
 291 -:       Result_Lists.Iterate (R.Result_List, Iterate_Success'Access);
 292 -:       return S_Count;
 293 .:    end Success_Count;
 294 .: 
 295 .:    ---------------
 296 .:    -- Successes --
 297 .:    ---------------
 298 .: 
 299 .:    procedure Successes (R : Result;
 300 .:                         S : in out Result_Lists.List) is
 301 -:       procedure Extract is new Gen_Extract (Is_Success);
 302 .:    begin
 303 -:       Extract (R, S);
 304 .:    end Successes;
 305 .: 
 306 .:    ----------------
 307 .:    -- Successful --
 308 .:    ----------------
 309 .: 
 310 .:    function Successful (R : Result) return Boolean is
 311 .:    begin
 312 -:       return Success_Count (R) = Test_Count (R);
 313 .:    end Successful;
 314 .: 
 315 .:    ----------------
 316 .:    -- Test_Count --
 317 .:    ----------------
 318 .: 
 319 .:    function Test_Count (R : Result) return Ada_Containers.Count_Type is
 320 .:    begin
 321 -:       return R.Tests_Run;
 322 .:    end Test_Count;
 323 .: 
 324 .:    -----------
 325 .:    -- Clear --
 326 .:    -----------
 327 .: 
 328 .:    procedure Clear (R : in out Result) is
 329 .:    begin
 330 -:       R.Tests_Run    := 0;
 331 -:       R.Elapsed_Time := Time_Measure.Null_Time;
 332 -:       Result_Lists.Clear (R.Result_List);
 333 .:    end Clear;
 334 .: 
 335 .: end AUnit.Test_Results;
