/home/chouteau/src/github/alire/ada_spark_workflow/src/ada_spark_workflow-word_search-dictionary.adb:
87% of 30 lines covered
87% statement coverage (26 out of 30)

Coverage level: stmt
   1 .: with Ada.Text_IO;
   2 .: 
   3 .: with Ada_SPARK_Workflow.Resources;
   4 .: with Ada_SPARK_Workflow.Word_Search.Shuffle;
   5 .: 
   6 .: package body Ada_SPARK_Workflow.Word_Search.Dictionary
   7 .: with SPARK_Mode
   8 .: is
   9 .: 
  10 .:    ----------
  11 .:    -- Load --
  12 .:    ----------
  13 .: 
  14 .:    procedure Load (This : in out Instance;
  15 .:                    Min_Word_Len, Max_Word_Len : Positive)
  16 .:    is
  17 .:       use Word_Vector;
  18 .:       use Ada.Text_IO;
  19 .:       use type Ada.Containers.Count_Type;
  20 .: 
  21 .:       ----------------
  22 .:       -- Valid_Word --
  23 .:       ----------------
  24 .: 
  25 .:       function Valid_Word (Str : String) return Boolean
  26 +:       is (Str'Length in Min_Word_Len .. Max_Word_Len
  27 +:           and then
  28 +:           Str'Length <= Word.Max_Length
  29 +:           and then
  30 +:             (for all C of Str => C in 'a' .. 'z'));
  31 .: 
  32 +:       Res_Path : constant String := Resources.Resource_Path;
  33 +:       Filename : constant String := "/unixdict.txt";
  34 .: 
  35 +:       File : File_Type;
  36 .: 
  37 +:       Last : Natural;
  38 +:       Line : String (1 .. Word.Max_Length);
  39 .:    begin
  40 .: 
  41 .:       --  Make sure string concat will not overflow (happy SPARK is happy)
  42 +:       if Res_Path'Last >= Positive'Last - Filename'Length then
  43 -:          return;
  44 .:       end if;
  45 .: 
  46 +:       Open (File, In_File, Res_Path & Filename);
  47 +:       if not Is_Open (File) then
  48 -:          return;
  49 .:       end if;
  50 .: 
  51 +:       while not End_Of_File (File) loop
  52 +:          Get_Line (File, Line, Last);
  53 .: 
  54 .:          --  Dict full?
  55 +:          exit when Length (This.Words) = Capacity (This.Words);
  56 .: 
  57 .:          declare
  58 +:             W : constant String := Line (Line'First .. Last);
  59 .:          begin
  60 +:             if Valid_Word (W) then
  61 +:                Word_Vector.Append (This.Words, Word.Create (W));
  62 .:             end if;
  63 .:          end;
  64 .:       end loop;
  65 .: 
  66 +:       Close (File);
  67 .:       pragma Unreferenced (File);
  68 .:    end Load;
  69 .: 
  70 .:    --------------
  71 .:    -- Is_Empty --
  72 .:    --------------
  73 .: 
  74 .:    function Is_Empty (This : Instance) return Boolean
  75 +:    is (Word_Vector.Is_Empty (This.Words));
  76 .: 
  77 .:    --------------
  78 .:    -- Pop_Last --
  79 .:    --------------
  80 .: 
  81 .:    procedure Pop_Last (This : in out Instance; W : out Word.Instance) is
  82 .:    begin
  83 +:       W := Word_Vector.Last_Element (This.Words);
  84 +:       Word_Vector.Delete_Last (This.Words);
  85 .:    end Pop_Last;
  86 .: 
  87 .:    --------------------
  88 .:    -- Random_Shuffle --
  89 .:    --------------------
  90 .: 
  91 .:    procedure Random_Shuffle (This : in out Instance) is
  92 +:       procedure Word_Vect_Shuffle
  93 +:       is new Ada_SPARK_Workflow.Word_Search.Shuffle (Word_Vector);
  94 .:    begin
  95 +:       Word_Vect_Shuffle (This.Words);
  96 .:    end Random_Shuffle;
  97 .: 
  98 .:    procedure Print (This : Instance) is
  99 .:    begin
 100 -:       for Elt of This.Words loop
 101 -:          Ada.Text_IO.Put_Line (Elt.To_Str);
 102 .:       end loop;
 103 .:    end Print;
 104 .: 
 105 .: end Ada_SPARK_Workflow.Word_Search.Dictionary;
